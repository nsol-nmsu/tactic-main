#include "Consumer.hpp"
#include <cassert>

namespace tactic {


NS_OBJECT_ENSURE_REGISTERED( Consumer );

ns3::TypeId
Consumer::GetTypeId( void ) {
    static ns3::TypeId tid =
        ns3::TypeId( "Consumer" )
        .AddAttribute(
            "WindowMin",
            "Minimum (and initial) window size for congestion control",
            ns3::UintegerValue( 5 ),
            ns3::MakeUintegerAccessor( &Consumer::m_windowMin ),
            ns3::MakeUintegerChecker<uint>()
        )
        .AddAttribute(
            "WindowMax",
            "Maximum window size for congestion control",
            ns3::UintegerValue( 25 ),
            ns3::MakeUintegerAccessor( &Consumer::m_windowMax ),
            ns3::MakeUintegerChecker<uint32_t>()
        )
        .AddAttribute(
            "RetxMax",
            "Maximum number of retransmissions per segment interest",
            ns3::UintegerValue( 3 ),
            ns3::MakeUintegerAccessor( &Consumer::m_retxMax ),
            ns3::MakeUintegerChecker<uint32_t>()
        )
        .AddAttribute(
            "InterestLifetime",
            "Lifetime assigned to interests generated by the consumer",
            ns3::TimeValue( ns3::Seconds( 1 ) ),
            ns3::MakeTimeAccessor( &Consumer::m_interestLifetime ),
            ns3::MakeTimeChecker()
        )
        .AddTraceSource(
            "NumSegmentsRequested",
            "The total number of segments requested, this does not "
            "include retransmissions, nor does it include any "
            "interests sent to retrieve an AuthTag.",
            ns3::MakeTraceSourceAccessor(
                &Consumer::m_numSegmentsRequested
            ),
            "ns3::TracedValueCallback::UInt"
        )
        .AddTraceSource(
            "NumSegmentsReceived",
            "The total number of segments received.",
            ns3::MakeTraceSourceAccessor(
                &Consumer::m_numSegmentsReceived
            ),
            "ns3::TracedValueCallback::UInt"
        )
        .AddTraceSource(
            "NumTimeoutsOccured",
            "The total number of request timeouts that have occured.",
            ns3::MakeTraceSourceAccessor(
                &Consumer::m_numTimeoutsOccured
            ),
            "ns3::TracedValueCallback::UInt"
        )
        .AddTraceSource(
            "SumResponseDelay",
            "The summation of response delays for all received "
            "segments.  This is the delay from the first interest "
            "sent for the segment to its ultimate recept.  It is "
            "not the delay from the last retransmission. ",
            ns3::MakeTraceSourceAccessor(
                &Consumer::m_sumResponseDelay
            ),
            "ns3::TracedValueCallback::UInt"
        );
    return tid;
}

ns3::TypeId
Consumer::GetInstanceTypeId( void ) const {
    return GetTypeId();
}


Consumer::Consumer(
    ndn::Name const& consumerName,
    ndn::Name const& contentName
) : m_consumerName( consumerName )
  , m_nonceRng( ns3::Create<ns3::UniformRandomVariable>() )
  , m_rttEst( ns3::Create<ns3::RttMeanDeviation>() )
{
    if( contentName.get( 0 ) != KEYWORD_TACTIC )
        throw Error( "Invalid content name" );
    
    auto getIt =
        std::find(
            contentName.begin(),
            contentName.end(),
            KEYWORD_DATA
        );
    if( getIt == contentName.end() )
        throw Error( "Invalid content name" );
    
    
    std::for_each(
        contentName.begin() + 1,
        getIt,
        [this]( ndn::Name::Component const& comp ) {
            m_producerName.append( comp );
        }
    );
    
    std::for_each(
        getIt + 1,
        contentName.end(),
        [this]( ndn::Name::Component const& comp ) {
            m_contentName.append( comp );
        }
    );
}

void
Consumer::Start( SPtr< Interface > iface ) {
    m_iface      = iface;
    m_nextSeg    = 0;
    m_lastSeg    = UINT_MAX - 1;
    m_authTag    = Maybe< AuthTag >();
    m_windowSize = m_windowMin;
    m_windowFill = 0;
    m_onFinish.clear();
    m_onFail.clear();
    m_numSegmentsRequested = 0;
    m_numSegmentsReceived  = 0;
    m_numTimeoutsOccured   = 0;
    m_sumResponseDelay     = ns3::Seconds( 0 );
    
    FillWindow();
}

void
Consumer::Stop( void ) {
    // Set m_nextSeg >= m_lastSeg to halt the consumer
    // after the current pending requests timeout or
    // or finish.
    m_nextSeg = UINT_MAX;
}

void
Consumer::FillWindow( void ) {
    // Already finished?
    if( m_nextSeg > m_lastSeg ) {
        for( auto& cb : m_onFinish )
            cb();
        return;
    }
    
    
    // If we don't have a valid AuthTag then
    // request one, we can't do anything else
    // until we've received authentication.
    if( !m_authTag || !m_authTag->IsActive() )
        RequestAuth();
    else {
        // If there's stuff in the retransmit queue
        // then resent those before adding anything
        // new to the window.
        while( !m_retx.empty() && m_windowFill < m_windowSize )
            RetransmitNext();
        
        // If we've finished all retransmits and there's still
        // window space left, then request the next sequence
        // of segments.
        while( m_windowFill < m_windowSize && m_nextSeg <= m_lastSeg )
            RequestNext();
    }
}

void
Consumer::RequestNext( void ) {
    // Make the request.
    auto request =
        std::make_shared<DataRequest>(
            m_producerName,
            m_contentName,
            *m_authTag,
            m_nextSeg++
        );
    
    // Make pending request info.
    auto pending = std::make_shared<PendingRequest>();
    pending->request = request;
    pending->retxNum = 0;
    pending->txTime  = ns3::Simulator::Now();
    pending->rxTime  = pending->txTime;
    
    // Schedule timeout.
    pending->toEvent =
        ns3::Simulator::Schedule(
            pending->rxTime + m_rttEst->GetEstimate(),
            &Consumer::OnTimeout,
            this,
            pending
        );
    

    // Invoke callbacks;
    for( auto& cb : m_onRequest )
        cb( std::static_pointer_cast<Request>( request ) );
    
    // Send it.
    using namespace std::placeholders;
    auto cb = std::bind( &Consumer::OnResponse, this, pending, _1 );
    m_iface->Submit( request, cb );
    m_numSegmentsRequested++;
}

void
Consumer::RequestAuth( void ) {
    // Make the request.
    auto request =
        std::make_shared<AuthRequest>( m_contentName, m_consumerName );
    
    // Make pending request info.
    auto pending = std::make_shared<PendingRequest>();
    pending->request = request;
    pending->retxNum = 0;
    pending->txTime  = ns3::Simulator::Now();
    pending->rxTime  = pending->txTime;
    
    // Schedule timeout.
    pending->toEvent =
        ns3::Simulator::Schedule(
            pending->rxTime + m_rttEst->GetEstimate(),
            &Consumer::OnTimeout,
            this,
            pending
        );
    

    // Invoke callbacks;
    for( auto& cb : m_onRequest )
        cb( std::static_pointer_cast<Request>( request ) );
    
    // Send it.
    using namespace std::placeholders;
    auto cb = std::bind( &Consumer::OnResponse, this, pending, _1 );
    m_iface->Submit( request, cb );
}

void
Consumer::RetransmitNext( void ) {
    
    // Take the next pending request from queue.
    auto pending = m_retx.front(); m_retx.pop();
    
    // Re-schedule the timeout event.
    pending->retxNum++;
    pending->rxTime = ns3::Simulator::Now();
    pending->toEvent =
        ns3::Simulator::Schedule(
            pending->rxTime + m_rttEst->GetEstimate(),
            &Consumer::OnTimeout,
            this,
            pending
        );
    
    // Now update the request.
    auto request = pending->request;
    if( request->GetType() == Request::TYPE_AUTH )
        pending->request =
            std::make_shared<AuthRequest>( (AuthRequest&)*request );
    else
        pending->request =
            std::make_shared<DataRequest>( (DataRequest&)*request );
    
    // Send the request.
    using namespace std::placeholders;
    auto cb = std::bind( &Consumer::OnResponse, this, pending, _1 );
    m_iface->Submit( request, cb );
}


void
Consumer::IncWindow( void ) {
    m_windowSize++;
    FillWindow();
}

void
Consumer::DecWindow( void ) {
    m_windowSize--;
    assert( m_windowFill <= m_windowSize );
}

void
Consumer::OnResponse( SPtr< PendingRequest > p, SPtr< Response > r ) {

    // Cancel timeout.
    p->toEvent.Cancel();
    
    // Decrease pending requests.
    m_windowFill--;
    
    // Tell the RTT estimator how long the transaction took.
    auto delay = p->rxTime - ns3::Simulator::Now();
    m_rttEst->Measurement( delay );
    
    // Trace delay.
    m_sumResponseDelay += delay;
    
    // If response is an AuthResponse then set its tag as new m_authTag.
    if( r->GetType() == Response::TYPE_AUTH ) {
        *m_authTag = AuthTag( ((AuthResponse&)r).GetAuthTag() );
    }
    // If response is a DataResponse then make it tell us what
    // the final segment of the content is.
    else {
        m_lastSeg = ((DataResponse&)r).GetLastSeg();
        m_numSegmentsReceived++;
    }
    
    // Invoke callbacks.
    for( auto& cb : m_onResponse )
        cb( r );
    
    // Increase window size, possibly sending out new requests.
    IncWindow();
}

void
Consumer::OnTimeout( SPtr< PendingRequest > p ) {
    
    // Tell the m_rttEst to increase estimate.
    auto delay = ns3::Simulator::Now() - p->rxTime;
    m_rttEst->Measurement( delay*2 );
    
    // Trace timeout.
    m_numTimeoutsOccured++;
    
    // Decrease window size.
    DecWindow();
    
    // Schedule retransmit if any are left.
    if( p->retxNum < m_retxMax ) {
        m_retx.push( p );
        FillWindow();
    }
    // Otherwise fail.
    else
        OnFailure();
}


void
Consumer::OnFailure( void ) {
    // Set m_nextSeg > m_lastSeg to indicate that there's
    // nothing more to do.
    m_nextSeg = UINT_MAX;
    
    // Invoke callbacks.
    for( auto& cb : m_onFail )
        cb();
}

};
